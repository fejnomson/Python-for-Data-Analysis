# Combining and merging dat sets
pandas.merge # join rows based on keys


# db style df merges
df1 = DataFrame({
	'key': ['b', 'b', 'a', 'c', 'a', 'a', 'b'],
	'data1': range(7)
})
df2 = DataFrame({
	'key': ['a', 'b', 'd'],
	'data2': range(3)
})
df1
df2
pd.merge(df1, df2) # many to one; but drops if not in both tables
pd.merge(df1, df2, on = 'key')
df3 = DataFrame({
	'lkey': ['b', 'b', 'a', 'c', 'a', 'a', 'b'],
	'data1': range(7)
})
df4 = DataFrame({
	'rkey': ['a', 'b', 'd'],
	'data2': range(3)
})
pd.merge(df3, df4, left_on = 'lkey', right_on = 'rkey')
# inner join: output keys are intersection of input keys
# outer join: union of the two keys
pd.merge(df1, df2, how = 'outer')

df1 = DataFrame({
	'key': ['b', 'b', 'a', 'c', 'a', 'b'],
	'data1': range(6)
})
df2 = DataFrame({
	'key': ['a', 'b', 'a', 'b', 'd'],
	'data2': range(5)
})
pd.merge(df1, df2, on = 'key', how = 'left')
pd.merge(df1, df2, how = 'inner')
left = DataFrame({
	'key1': ['foo', 'foo', 'bar'],
	'key2': ['one', 'two', 'one'],
	'rval': [1, 2, 3]
})
right = DataFrame({
	'key1': ['foo', 'foo', 'bar', 'bar'],
	'key2': ['one', 'one', 'one', 'two'],
	'rval': [4, 5, 6, 7]
})
pd.merge(left, right, on = ['key1', 'key2'], how = 'outer')
pd.merge(
	left, right, on = 'key1', suffixes = ('_left', '_right')
)
# not sure if i've used this before, but LOVE having control over the
# 	suffixes
# Wondering when and why you'd turn 'copy' off / why it always copies by
# 	default.


# Merging on Index
left1 = DataFrame({
	'key': ['a', 'b', 'a', 'a', 'b', 'c'],
	'value': range(6)
})
right1 = DataFrame({'group_val': [3.5, 7]},	index = ['a', 'b'])
pd.merge(left1, right1, left_on = 'key', right_index = True)
pd.merge(left1, right1, left_on = 'key', right_index = True, how = 'outer')
lefth = DataFrame({
	'key1': ['Ohio', 'Ohio', 'Ohio', 'Nevada', 'Nevada'],
	'key2': [2000, 2001, 2002, 2001, 2002],
	'data': np.arange(5.)
})
righth = DataFrame(
	np.arange(12).reshape((6, 2)),
	index = [
		['Nevada', 'Nevada', 'Ohio', 'Ohio', 'Ohio', 'Ohio'],
		[2001, 2000, 2000, 2000, 2001, 2002]
	],
	columns = ['event1', 'event2']
)
pd.merge(lefth, righth, left_on = ['key1', 'key2'], right_index = True)
pd.merge(
	lefth,
	righth,
	left_on = ['key1', 'key2'],
	right_index = True,
	how = 'outer'
)
left2 = DataFrame(
	[[1., 2.], [3., 4.], [5., 6.]],
	index = ['a', 'c', 'e'],
	columns = ['Ohio', 'Nevada']
)
right2 = DataFrame(
	[[7., 8.], [9., 10.], [11., 12.], [13, 14]],
	index = ['b', 'c', 'd', 'e'],
	columns = ['Missouri', 'Alabama']
)
pd.merge(left2, right2, how = 'outer', left_index = True, right_index = True)
# JOIN() METHOD IS INTENDED FOR MERGING BY INDEX
left2.join(right2, how = 'outer') # can also use to join list of DFs together by index
left1.join(right1, on = 'key') # can do ix one one, columns on another
another = DataFrame(
	[[7., 8.], [9., 10.], [11., 12.], [16., 17.]],
	index = ['a', 'c', 'e', 'f'],
	columns = ['New York', 'Oregon']
)
left2.join([right2, another]) # alternative to pd.concat(), not sure why you'd do one or the other though
left2.join([right2, another], how = 'outer')


# Concatenating Along an Axis
sl = Series([0, 1], index = ['a', 'b'])
s2 = Series([2, 3, 4], index = ['c', 'd', 'e'])
s3 = Series([5, 6], index = ['f', 'g'])
pd.concat([sl, s2, s3])
pd.concat([sl, s2, s3], axis = 1)
s4 = pd.concat([sl*5, s3])
pd.concat([sl, s4], axis = 1)
# by column, union of keys
pd.concat([sl, s4], axis = 1, join = 'inner')
# by column, intersect of keys
pd.concat([sl, s4], axis = 1, join_axes = [['a', 'c', 'b', 'e']])
# specify which keys to join on
result = pd.concat([sl, sl, s3], keys = ['one', 'two', 'three'])
result
# So you can keep track of which obs. came from which chunk
result.unstack()
pd.concat([sl, s2, s3], axis = 1, keys = ['one', 'two', 'three'])
# keys become col names if you go by cols
df1 = DataFrame(np.arange(6).reshape(3, 2), index = ['a', 'b', 'c'], columns = ['one', 'two'])
df2 = DataFrame(5 + np.arange(4).reshape(2, 2), index = ['a', 'c'], columns = ['three', 'four'])
pd.concat([df1, df2], axis = 1, keys = ['level1', 'level2'])
# looks like it stacks the columns automatically, then throws the 'key' / level on top of each group of columns.
pd.concat({'level1': df1, 'level2': df2}, axis = 1)
# if pass dict, dicts keys are automatically used as keys
pd.concat([df1, df2], axis = 1, keys = ['level1', 'level2'], names = ['upper', 'lower'])
# name the keys you pass that become an index
stopped top of page 188




