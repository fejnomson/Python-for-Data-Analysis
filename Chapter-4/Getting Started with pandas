from pandas import Series, DataFrameimport pandas as pd# Series# kind of like numpy array with indexobj = Series([4, 7, -5, 3])objobj.indexobj.valuesnp.array([4, 7, -5, 3], dtype = np.int64)# so it's basically like a wrapper for np.array, mostly labels and methods...obj2 = Series([4, 7, -5, 3], index = ['d', 'b', 'a', 'c'])obj2obj2.indexobj2['a']obj2[['a', 'd']]# although explained at ordered dict; substituted in many functions that#  expect a dict'b' in obj2'e' in obj2sdata = {'Ohio': 35, 'Texas': 71, 'Oregon':16, 'Utah': 5}obj3 = Series(sdata)states = ['California', 'Ohio', 'Oregon', 'Texas']obj4 = Series(sdata, index = states)# Series will match dict keys with object you pass as indexpd.isnull(obj4) # is.na()pd.notnull(obj4) # top level methodsobj4.isnull()obj4.notnull() # instance methodsobj3obj4obj3 + obj4 # computations are aligned along index, auto data alignmentobj4.name = 'population'obj4.index.name = 'state'# name series and index attributeobj.index = ['bob', 'steve', 'jeff', 'ryan']# mod index in place# DataFrame# more of a dict of series that all share the same index# row and column operations are symetrical; super different than R# data are stored in 2d blocks, RATHER THAN list or dict; this is very#  different than R where its a list of vectorsdata = { 'state': ['Ohio', 'Ohio', 'Ohio', 'Nevada', 'Nevada'], 'year': [2000, 2000, 2000, 2000, 2000], 'pop': [1.5, 1.7, 3.6, 2.4, 2.9]}frame = DataFrame(data)DataFrame(data, columns = ['year', 'state', 'pop'])# note cols are in different order; list matched with dict keysframe2 = DataFrame( data, columns = ['year', 'state', 'pop', 'debt'], index = ['one', 'two', 'three', 'four', 'five'])frame2.columnsframe2['state']frame2.yearval = Series([-1.2, -1.5, -1.7], index = ['two', 'four', 'five'])frame2['debt'] = valframe2['eastern'] = frame2.state == 'Ohio'frame2del frame2['debt']# indexing df column returns VIEW not COPYx = frame2['pop']xx['three'] = 9999.0frame2pop = { 'Nevada': {  2001: 2.4, 2002: 2.9 }, 'Ohio': {  2000: 1.5, 2001: 1.7, 2002: 3.6 }}frame3 = DataFrame(pop) # ix is sorted union of keysDataFrame(pop, index = [2001, 2002, 2003]) # unless you explicitly saypdata = { 'Ohio': frame3['Ohio'][:-1], 'Nevada': frame3['Nevada'][:2]}frame2.values # returns 2D np array.# Index Objectsobj = Series(range(3), index = ['a', 'b', 'c'])index = obj.indexindex[1] = 'd' # immutableindex = pd.Index(np.arange(3))obj2 = Series([1.5, -2.5, 0], index = index)obj2.index is indexframe3'Ohio' in frame3.columns# there are a bunch of index-specific properties and methodsframe3.indexframe3.index.union([2001, 2004])frame3.index.isin([2001, 2004])frame3.index.drop([2001])frame3.index.insert(1, 2001)frame3.index.is_monotonicframe3.index.is_uniqueframe3.index.unique()# Essential Functionalityobj = Series([4.5, 7.2, -5.3, 3.6], index = ['d', 'b', 'a', 'c'])obj2 = obj.reindex(['a', 'b', 'c', 'd', 'e'])obj.reindex(['a', 'b', 'c', 'd', 'e'], fill_value = 0)obj3 = Series(['blue', 'purple', 'yellow'], index = [0, 2, 4])obj3.reindex( # still don't entirely understand reindexing range(6), method = 'ffill' # forward fills missing values)frame = DataFrame( np.arange(9).reshape((3, 3)), index = ['a', 'c', 'd'], columns = ['Ohio', 'Texas', 'California'])frame2 = frame.reindex(['a', 'b', 'c', 'd'])states = ['Texas', 'Utah', 'California']frame.reindex(columns = states)frame.reindex( index = ['a', 'b', 'c', 'd'], method = 'ffill', columns = states)page 141
